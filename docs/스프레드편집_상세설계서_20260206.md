# 에디터 스프레드 편집 - 세부 설계

## Context

현재 storige 에디터는 표지/책등/날개/내지를 **각각 개별 Fabric.js 캔버스**로 편집한다.
이를 **표지 스프레드 뷰** (뒷날개-뒷표지-책등-앞표지-앞날개를 하나의 캔버스)로 변경하여 인쇄물의 실제 펼침 상태를 직관적으로 편집할 수 있게 한다.

핵심 과제: 내지 페이지 수에 따라 책등 가로 크기가 동적으로 변하며, 이에 따라 캔버스 크기와 영역 위치가 자동 조정되어야 한다.

---

## 1. 기능 정의서

### 1.0 에디터 모드 구분

에디터는 **두 가지 모드**를 지원한다:

| 모드 | 설명 | 페이지 패널 | 적용 기준 |
|------|------|------------|----------|
| **단일모드** (기존) | 각 페이지를 개별 캔버스로 편집 | 좌측 사이드바 (기존 유지) | 기본값 |
| **책모드** (신규) | 표지를 스프레드 캔버스로 편집 | 하단 수평 패널 | 상품 설정에서 선택 |

**모드 결정**: TemplateSet 엔티티의 `editorMode: 'single' | 'book'` 필드
- 단일모드: 현재와 완전히 동일한 동작 (코드 변경 없음)
- 책모드: 아래 기능 정의 적용

**템플릿 구성 차이**:
- 단일모드 TemplateSet: `[cover] [spine] [wing] [page] [page] ...` (개별 템플릿)
- 책모드 TemplateSet: `[spread] [page] [page] ...` (스프레드 1개 + 내지 N개)

**스프레드 템플릿**: 새로운 TemplateType `SPREAD`
- 뒷날개+뒷표지+책등+앞표지+앞날개를 **하나의 canvasData**로 저장
- 관리자가 스프레드 에디터(iframe)에서 직접 편집하여 생성
- Template.metadata에 SpreadConfig(영역 구성 정보) 저장

### 1.1 스프레드 캔버스 레이아웃 (책모드)

```
┌──────────────────────────────────────────────────────────────────┐
│                        재단여백 (bleed)                           │
│  ┌─────────┬──────────┬────────┬──────────┬─────────┐           │
│  │         │          │        │          │         │           │
│  │ 뒷날개   │  뒷표지   │  책등   │  앞표지   │ 앞날개   │           │
│  │ (선택)   │          │ (동적)  │          │ (선택)   │           │
│  │  60mm   │  210mm   │ 7.5mm  │  210mm   │  60mm   │           │
│  │         │          │        │          │         │           │
│  └─────────┴──────────┴────────┴──────────┴─────────┘           │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
       ↑점선        ↑점선      ↑점선      ↑점선       ↑점선
     가이드라인     가이드라인  가이드라인  가이드라인   가이드라인
```

**영역 구성**:
- 날개 포함 여부는 **상품 설정**에 따라 선택적
- 날개 없는 상품: `[뒷표지]-[책등]-[앞표지]`
- 날개 있는 상품: `[뒷날개]-[뒷표지]-[책등]-[앞표지]-[앞날개]`

### 1.2 동적 책등 크기 변경

**트리거**: 내지 페이지 추가/삭제

**동작**:
1. 내지 수 변경 → API로 책등 폭 재계산 (debounce 300ms + in-flight cancel)
2. 캔버스 전체 가로 크기 증감
3. 책등 우측의 모든 영역(앞표지, 앞날개) 좌우 이동

**객체 앵커 메타데이터**:

모든 사용자 객체에 앵커 메타를 부여하여 리사이즈 시 의도를 명확하게 함:
```typescript
object.meta.regionRef: SpreadRegionPosition | null  // 소속 영역 (null = 자유 객체)
object.meta.primaryRegionHint: SpreadRegionPosition | null  // UX용 주 영역 힌트 (자유 객체에도 설정)
object.meta.anchor:
  | { kind: 'region', xNorm: number, yNorm: number }  // 영역 기준 정규화 좌표
  | { kind: 'canvas', x: number, y: number }           // 캔버스 절대 좌표
```

**anchor 기준점 규칙** (구현자 해석 차이 방지):
- **항상 객체의 중심점(center) 기준**으로 정의
- `xNorm`: (객체중심.x - region.x) / region.width → 0~1 정규화
- `yNorm`: (객체중심.y - region.y) / region.height → 0~1 정규화
- originX/originY가 'left'/'top'인 객체도 중심점으로 **환산하여** 저장/복원
- canvas anchor도 동일: `x`, `y`는 workspace 좌표계에서의 객체 중심점

**xNorm/yNorm 유효 범위**:
- 클램프하지 않음 (0 미만/1 초과 허용) → 디자인 의도 보존
- 단, 극단값 상한: **-1.0 ~ 2.0** 범위로 제한 (리사이즈 시 객체가 과도하게 멀리 튀는 것 방지)
- 범위 초과로 인한 강등은 **사용자 이동 완료 시점(handleObjectModified)에서만** 수행
- **resizeSpine 과정에서는 강등하지 않는다** (레이아웃 보정으로 상태가 바뀌는 것 방지)

- **영역 객체** (regionRef 있음, anchor.kind='region'): 리사이즈 시 영역과 함께 이동/재배치
- **자유 객체** (regionRef=null, anchor.kind='canvas'): 리사이즈 시 절대좌표 유지 → 걸치기 허용
- 객체 배치/이동 시 SpreadPlugin이 자동으로 regionRef/anchor 갱신
- 객체가 여러 영역에 걸치면 regionRef=null (자유 객체)로 판정

**캔버스 밖 객체 UX** (스프레드 폭 감소 시):
- spine 폭 감소 → 캔버스 총폭 감소 → 자유 객체가 오른쪽 밖으로 나갈 수 있음
- 경고 토스트: "캔버스 밖으로 나간 객체가 있습니다"
- **토스트 클릭 시**: 화면 밖 객체로 zoom/pan to fit selection (최소 접근 장치)
- 다음 스프린트: "캔버스 밖 객체 찾기" 패널 추가

**영역별 리사이즈 동작**:

| 영역 | 객체 처리 방식 |
|------|--------------|
| 뒷날개 | 변동 없음 (좌표 유지) |
| 뒷표지 | 변동 없음 (좌표 유지) |
| 책등 | 타입별 Strategy 적용 (아래 참고) |
| 앞표지 | 영역과 함께 이동 (영역 내 상대좌표 유지) |
| 앞날개 | 영역과 함께 이동 (영역 내 상대좌표 유지) |
| 자유 객체 | 캔버스 절대좌표 유지 (걸치기 그대로) |

**책등 객체 타입별 리사이즈 Strategy**:

| 타입 | 전략 |
|------|------|
| **i-text/Textbox** | 스케일 금지, 영역 중앙 재정렬만 수행 (폰트 렌더링 품질 보존) |
| **Image** | 비례 스케일: `scaleX *= ratio, scaleY *= ratio` + `strokeUniform = true` 강제 + `strokeWidth` 값 유지. clipPath/shadow/pattern/cornerRadius는 건드리지 않음(Next) |
| **Group (텍스트 포함)** | 스케일 금지 + 중앙 재정렬만 (그룹 풀기 없음, MVP 단순화) |
| **Group (텍스트 미포함)** | 비례 스케일 허용 |

**텍스트 포함 Group 판정 기준**:
- 그룹 트리 내에 `type in ['i-text', 'textbox', 'text']` 존재 여부로 판정
- 1회 계산 후 `group.meta.containsText = true/false`로 캐싱 가능
| **기타 (Rect, Path 등)** | 비례 스케일 허용 |

**책등 최소 폭**: 제본 방식별 최소 페이지 수 제한 적용
- 무선제본: 32p 이상
- 중철제본: 4p 이상 (4의 배수)

**변경 알림**: 토스트 메시지 ("책등 폭이 7.5mm로 변경되었습니다")

**히스토리 정책**:
- 내지 추가/삭제: 히스토리 대상 (문서 구조 변경)
- 책등 폭 변경 (레이아웃 보정): 히스토리 **비대상** → 별도 layout transaction
- resizeSpine()은 단일 atomic transaction: `renderAll off → batch update → renderAll on`

### 1.3 가이드라인 및 치수 표시

**영역 경계**: 점선만 (색상: 회색 계열)

**영역 치수 표시**:
- 각 영역 상단에 mm 단위 가로 크기 표시
- 책등 변경 시 실시간 업데이트
- 예: `210mm`, `7.5mm`, `60mm`

**영역 스냅 가이드**:
- 객체 이동 시 영역 경계선에 스냅
- 객체 이동 시 영역 중앙에 스냅
- 스냅 강도: 기존 스냅 가이드와 동일

### 1.4 재단선 (Bleed)

- 스프레드 전체 외곽(상하좌우)에만 재단여백
- 내부 영역 경계에는 재단선 없음
- 기존 cutBorder 표시 방식 활용

### 1.5 객체 배치

- **자유 배치**: 영역 경계와 무관하게 자유롭게 배치 가능
- 뒷표지에서 책등으로 걸치는 이미지 등 허용
- PDF 출력 시 스프레드 전체가 하나의 페이지이므로 클리핑 불필요
- **앵커 자동 판정**: 객체 이동/배치 완료 시 SpreadPlugin이 regionRef/anchor 자동 갱신

**판정 규칙 (히스테리시스 적용)**:

바운딩 기준:
- region 판정은 '**인쇄 유효 영역**' 기준이며, **viewportTransform 반영 + stroke 포함**이 목표
- 실제 호출 시그니처는 Fabric 버전에 맞춘다 (특정 API 형태가 아닌 **결과 의미**를 규격화)
- 테스트는 'stroke 포함/미포함 케이스'로 **결과 기준을 검증**
- 상품/편집기 전체에서 **이 1개 기준만 사용** (옵션으로 두지 않음)
- shadow/blur는 논리적으로 제외한다. 다만 Fabric 바운딩이 shadow를 포함할 경우, 판정용 rect는 **별도 계산(shadow 제거한 임시 측정)으로 구현**
- 스냅은 stroke 미포함 기준 사용 가능 (판정과 역할 분리)

회전 객체 포함율:
- 포함율은 '**객체 boundingRect(축 정렬 AABB)**' 기준으로 영역과의 **교차 면적 비율**로 계산
- 회전 여부와 무관하게 동일 규칙 적용 (정밀 폴리곤 교차 불필요, AABB로 고정)
- 교차 면적이 0이면 포함율 **0**으로 간주
- 객체 AABB 면적이 0(선/점)인 경우: 중심점이 영역 안이면 **1**, 아니면 **0**

히스테리시스:
- **승격** (자유 → 영역): 현재 `regionRef=null`이고, 바운딩 박스가 단일 영역에 **90% 이상** 포함 시
- **강등** (영역 → 자유): 현재 `regionRef`가 존재하고, 바운딩 박스가 소속 영역에 **70% 미만** 포함 시
- **유지**: 현재 `regionRef`가 존재하면 **70% 이상인 동안은 regionRef를 유지**한다
- 현재 `regionRef=null`이면 **90% 이상일 때만 승격**한다

걸쳐 있는 자유 객체: `regionRef=null` + `primaryRegionHint` 저장

**primaryRegionHint 역할 범위**:
- **적용**: 스냅(영역 경계/중앙), 정렬 메뉴에서 "이 영역 기준 정렬"
- **비적용**: 리사이즈 재배치, PDF 출력, 서버 검증

### 1.6 배경 설정

- **전체 통일 배경**: 스프레드 전체에 하나의 배경색/이미지 적용
- **영역별 오버라이드**: 앞표지/뒷표지/책등/날개 각각 다른 배경 설정 가능
- 우선순위: 영역별 배경 > 전체 배경

### 1.7 책등 텍스트

- **수동 설정**: 사용자가 직접 텍스트 방향과 크기 설정
- 자동 방향 전환 없음

### 1.8 PDF 출력

#### 출력 구조

스프레드 모드(책모드)에서는 **항상 2개 PDF로 분리 출력**:

| PDF | 내용 | 페이지 수 |
|-----|------|----------|
| **cover.pdf** | 스프레드 캔버스 전체 (뒷날개+뒷표지+책등+앞표지+앞날개) | **1페이지** |
| **content.pdf** | 내지 캔버스들 | **N페이지** |

- 스프레드 캔버스는 재단여백(bleed) 포함하여 **1장짜리 PDF**로 렌더링
- 내지 캔버스들은 순서대로 병합하여 **N장짜리 PDF**로 렌더링

#### 에디터 → PDF 생성 흐름

```
1. 에디터 "완료" 클릭
2. 각 캔버스에서 PDF 생성:
   - allCanvas[0] (스프레드) → 개별 PDF 업로드 → fileId 획득
   - allCanvas[1~N] (내지)   → 개별 PDF들 업로드 → fileIds 획득
3. EditSession 완료 API 호출 (status='complete')
4. API에서 자동으로 Worker Job 생성:
   - mode: 'spread'
   - spreadPdfFileId: 스프레드 PDF fileId
   - contentPdfFileIds: [내지 PDF fileId, ...]
   - outputFormat: 'separate' (항상 분리)
```

#### Worker 처리 흐름 (mode='spread')

```
1. 스프레드 PDF 로드 → cover.pdf로 저장 (1페이지, 그대로)
2. 내지 PDF들 로드 → 순서대로 병합 → content.pdf 저장
3. (선택) merged.pdf 생성: cover(1p) + content(Np) 합본
4. 출력 파일 저장:
   outputs/${jobId}/
   ├── cover.pdf     (스프레드 = 표지 전체)
   ├── content.pdf   (내지 병합)
   └── merged.pdf    (선택, alsoGenerateMerged=true일 때)
5. 웹훅 콜백 전송
```

#### 웹훅 페이로드 (spread 모드)

```json
{
  "event": "synthesis.completed",
  "jobId": "job-123",
  "outputFormat": "separate",
  "outputFiles": [
    { "type": "cover", "url": "/storage/outputs/job-123/cover.pdf", "pageCount": 1 },
    { "type": "content", "url": "/storage/outputs/job-123/content.pdf", "pageCount": 32 }
  ],
  "outputFileUrl": "/storage/outputs/job-123/merged.pdf",
  "spreadMode": true
}
```

#### 기존 모드와의 차이

| 항목 | split (기존) | spread (신규) |
|------|-------------|--------------|
| 입력 | 단일 PDF + pageTypes 배열 | 스프레드 PDF + 내지 PDF들 |
| 표지 분류 | pageTypes에서 'cover' 인덱스 추출 | 스프레드 PDF 전체가 표지 |
| 표지 페이지 수 | 가변 (1~N) | 항상 1페이지 |
| 분리 방식 | 페이지 인덱스 기반 추출 | 파일 자체가 이미 분리됨 |
| 병합 필요 | 내지 인덱스 추출 후 병합 | 내지 PDF들 순서 병합만 |

#### 설계 결정 사항

**내지 PDF 업로드 방식**:
- 이번 스프린트는 내지 PDF를 '**캔버스 단위 개별 업로드**'로 고정
- 성능 최적화(클라이언트에서 content.pdf 1개로 병합 후 업로드)는 다음 스프린트 검토 항목

**Webhook payload 필드 규격**:
- `outputFileUrl`: **항상 포함**하되, merged가 없으면 **null** (미포함이 아닌 null로 고정)
- `outputFiles`: 항상 cover/content **2개** 포함
- `spreadMode: true` 유지

**cover.pdf 사이즈 검증**:
- Worker는 cover.pdf의 **MediaBox(page size)**가 `EditSession.metadata.spread.totalWidthMm/totalHeightMm`(+dpi 변환)와 일치하는지 검증
- 불일치 시 **하드 실패** (인쇄 사고 방지, '추측 금지' 원칙)

**출력 재현의 단일 소스**:
- **EditSession.metadata.spread**가 유일한 소스
- Template.spreadConfig는 **초기화에만** 사용하며, 세션이 생성된 이후에는 출력/검증에서 참조하지 않는다

#### 단일모드(기존) PDF 출력

단일모드에서는 기존 split synthesis 그대로 사용:
- 각 캔버스(cover/spine/wing/page)에서 개별 PDF 생성
- pageTypes 배열로 표지/내지 분류
- Worker가 split 처리

### 1.9 데이터 호환

- **마이그레이션 불필요**: 신규 세션만 스프레드 모드 사용
- 기존 개별 페이지 세션은 그대로 유지
- **모드 전환 없음**: 스프레드 모드만 지원 (개별 페이지 전환 불가)

### 1.10 세션 데이터 스냅샷

내지 변경으로 spineWidth가 바뀌는 기능이므로, PDF 출력 시점에서 동일 값을 재현해야 한다.
외부 요인(종이 두께 변경, 제본 마진 정책 변경)이 생기더라도 저장된 값을 우선 사용한다.

**EditSession.metadata.spine에 저장**:
```typescript
{
  pageCount: number
  paperType: string
  bindingType: string
  spineWidthMm: number
  formulaVersion: string  // 계산 공식 버전 (향후 변경 대비)
}
```

**EditSession.metadata.spread에 저장** (출력 재현용):
```typescript
{
  spec: SpreadSpec       // 최소 스펙 (coverWidth, coverHeight, wingEnabled 등)
  totalWidthMm: number   // 스프레드 총 폭
  totalHeightMm: number  // 스프레드 총 높이
  dpi: number
}
```
- **스냅샷 갱신 시점**: spine API 응답 수신 + resizeSpine **성공 이후에만** 커밋
- API 요청 중 실패/취소되면 스냅샷은 갱신하지 않는다
- Worker PDF 출력 시: 저장된 스냅샷 우선 사용 (재계산 금지)
- 스냅샷 실패/경고 기준: §4.7 Worker 기준 참고 (spine/spread 필수값 누락=하드 실패, UI 메타 누락=소프트 경고)

---

## 2. UI 변경사항

### 2.1 하단 페이지 패널 (기존: 좌측 사이드 → 변경: 하단 수평)

```
┌─────────────────────────────────────────────────────────┐
│                    에디터 메인 영역                        │
│                   (캔버스 + 도구바)                        │
│                                                           │
├─────────────────────────────────────────────────────────┤
│ [표지 스프레드 썸네일] || [내지1] [내지2] [내지3] ... [+]  │
│     (넓은 가로형)       │    (정방형 썸네일 나열)           │
└─────────────────────────────────────────────────────────┘
```

**특징**:
- 좌측: 스프레드 썸네일 (가로로 넓게)
- 구분선: 표지 영역과 내지 영역 시각적 구분
- 우측: 내지 썸네일 수평 나열 + 추가(+) 버튼
- **항상 표시** (hide 옵션 없음, 기본 show)
- 내지 추가/삭제 시 책등 자동 재계산 트리거
- **썸네일 갱신**: 자동저장 완료 이벤트에만 갱신 (실시간 캡처 X, 프레임드랍/블러 방지)

### 2.2 3D 목업 미리보기

- **접근**: 에디터 상단 헤더의 '미리보기' 버튼
- **표시**: 모달 팝업으로 3D 책 목업
- **기능**: 앞표지-책등-뒷표지를 3D 책 형태로 확인
- **구현**: 간단한 CSS 3D transform 또는 canvas 기반 (이번 스프린트는 간단한 버전)

### 2.3 영역 치수 표시 UI

```
          210mm           7.5mm          210mm
  ←─────────────→  ←──────→  ←─────────────→
  ┌──────────────┬──────────┬──────────────┐
  │              │          │              │
  │   뒷표지      │   책등    │   앞표지      │
  │              │          │              │
  └──────────────┴──────────┴──────────────┘
```

- 캔버스 상단에 각 영역의 가로 크기 mm 표시
- 비편집 요소 (selectable: false, evented: false)
- **줌 보정**: 라벨 y는 workspace top 기준 + 고정 px margin(줌 보정), 텍스트는 mm 값만 갱신
- 줌이 바뀌어도 라벨이 떠다니지 않고 안정적 위치 유지

---

## 3. 경쟁 서비스 벤치마크 반영

| 기능 | 벤치마크 출처 | 반영 여부 |
|------|-------------|----------|
| 동적 책등 리사이즈 | BookCoversLab, Mixam, KDP | O (핵심 기능) |
| 영역 치수 표시 | InDesign | O |
| 영역 스냅 가이드 | InDesign | O |
| 3D 목업 미리보기 | BookCoversLab, Coverjig | O (간단한 버전) |
| 실시간 프리플라이트 | BookCoversLab | X (다음 스프린트) |
| 책등 텍스트 자동 리사이즈 | Mixam | X (수동 설정) |
| 360도 회전 미리보기 | Coverjig | X (간단한 3D만) |

Sources:
- [BookCoversLab](https://bookcoverslab.com/kdp-cover-creator)
- [Mixam Design Online](https://mixam.com/support/designonline)
- [Lulu Cover Designer](https://blog.lulu.com/lulus-book-cover-designer/)
- [Amazon KDP Cover Creator](https://kdp.amazon.com/en_US/help/topic/G201113520)
- [Coverjig](https://www.coverjig.com/)

---

## 4. 구현 설계

### 4.1 SpreadLayoutEngine (Pure) + SpreadPlugin (Impure) 분리

**설계 원칙**: 순수 레이아웃 계산과 Fabric.js 부수효과를 분리하여 테스트 가능 구조 확보

#### 4.1.1 SpreadLayoutEngine (Pure)

**새 파일**: `packages/canvas-core/src/spread/SpreadLayoutEngine.ts`

외부 의존 없는 순수 함수. 입력으로 스펙을 받아 레이아웃 결과를 출력.

```typescript
// 입력
interface SpreadSpec {
  coverWidthMm: number
  coverHeightMm: number
  spineWidthMm: number
  wingEnabled: boolean
  wingWidthMm: number
  cutSizeMm: number
  safeSizeMm: number
  dpi: number
}

// 출력
interface SpreadLayout {
  regions: SpreadRegion[]
  guides: GuideLineSpec[]      // 점선 가이드 좌표
  labels: DimensionLabel[]     // mm 치수 라벨
  totalWidthPx: number
  totalHeightPx: number
  totalWidthMm: number
  totalHeightMm: number
}

interface SpreadRegion {
  type: 'wing' | 'cover' | 'spine'
  position: SpreadRegionPosition
  x: number          // workspace px (Fabric canvas 좌표)
  width: number       // workspace px
  height: number      // workspace px
  widthMm: number
  heightMm: number
  label: string
}
```

**핵심 함수**:
- `computeLayout(spec: SpreadSpec): SpreadLayout` - 전체 레이아웃 계산
- `computeResizedLayout(currentLayout, newSpineWidthMm): SpreadLayout` - 책등 리사이즈 후 레이아웃
- `resolveRegionAtX(regions, x): SpreadRegion | null` - x 좌표 → 영역 (단순 x-range 비교, z-order 불필요)
- `computeObjectReposition(object, oldLayout, newLayout): RepositionResult` - 객체 재배치 계산
- `resolveRegionRef(regions, boundingRect, currentRegionRef): RegionRefResult` - 히스테리시스 적용 regionRef 판정
  - 승격 임계치: 90%, 강등 임계치: 70%
  - 반환: `{ regionRef, primaryRegionHint, anchor }`

**좌표계 원칙** (R3 반영):
- 내부 좌표계는 항상 **workspace px** (= Fabric canvas 좌표) 기준
- mm → px 변환은 오직 2곳에서만:
  1. `computeLayout()`에서 spec(mm) → layout(px) 초기 변환
  2. DimensionLabel 렌더링에서 px → mm 역변환 (표시용)
- 스냅 threshold: workspace px 고정, 줌 보정 시 `threshold = basePx / zoom`

#### 4.1.2 SpreadPlugin (Impure - Fabric 연동)

**새 파일**: `packages/canvas-core/src/plugins/SpreadPlugin.ts`

WorkspacePlugin 위에 레이어링. Fabric 오브젝트 생성/갱신 + 이벤트 핸들링 담당.

**핵심 메서드**:
- `init(spec: SpreadSpec)` - LayoutEngine으로 레이아웃 계산 → Fabric 오브젝트 생성
- `resizeSpine(newSpineWidthMm)` - resize transaction 오케스트레이션 (아래 알고리즘)
- `renderGuides(layout)` - 영역 경계 점선 Fabric Line 생성
- `renderLabels(layout)` - mm 치수 Fabric Text 생성
- `handleObjectModified(e)` - 객체 이동 완료 시 regionRef/anchor 자동 갱신
- `handleObjectMoving(e)` - 영역 경계/중앙 스냅

**시스템 객체 식별** (2.2 반영):
```typescript
obj.meta.system = 'workspace' | 'cutBorder' | 'safeBorder' | 'spreadGuide' | 'dimensionLabel'
```
- 리사이즈 시 skip 판정: `obj.meta?.system` 존재 여부로만 (타입/이름 추측 금지)
- `meta.system`은 **플러그인 생성 오브젝트에만** 부여한다
- 로드 시 사용자 객체에 `meta.system`이 존재하면 **하드 실패(validator violation)** 처리
  (soft로 두면 "왜 리사이즈가 안 되지?"가 운영에서 터짐)

**getRegionAtPoint** (2.3 반영):
- 단순 x-range 비교로 영역 판정 (성능 + 안정)
- 가이드라인은 UI 표시만 담당, hit-test에 관여하지 않음

**SpreadConfig** (저장용):
```typescript
interface SpreadConfig {
  spec: SpreadSpec               // 원본 스펙 (재계산 가능)
  regions: SpreadRegion[]        // 현재 레이아웃 결과
  totalWidthMm: number
  totalHeightMm: number
}
```

### 4.2 동적 책등 리사이즈 알고리즘

```
resizeSpine(newSpineWidthMm):
  // Atomic Transaction (render off → batch → render on)
  // ※ 순서 엄수: workspace 크기 확정 → 객체 재배치 → zoom auto

  1. canvas.renderOnAddRemove = false  // 렌더링 잠금

  2. newLayout = SpreadLayoutEngine.computeResizedLayout(currentLayout, newSpineWidthMm)
  3. if (newLayout.totalWidthPx === currentLayout.totalWidthPx): return

  4. WorkspacePlugin.setOptions({ size: { width: newLayout.totalWidthMm } })
     → workspace rect + 재단선 자동 업데이트 (먼저 확정)

  5. 캔버스 객체 재배치 (각 객체별):
     - skip: obj.meta?.system 존재하면 무시
     - if obj.meta?.regionRef === null (자유 객체):
         → 캔버스 절대좌표 유지 (변경 없음)
     - if obj.meta?.regionRef === 'spine':
         → SpineResizeStrategy 적용 (타입별):
           - i-text/Textbox: 스케일 금지, 새 spine 영역 중앙으로 재정렬만
           - Image: 비례 스케일 (newSpineWidth / oldSpineWidth) + MVP 보정(strokeUniform+strokeWidth만)
           - Group (텍스트 포함): 스케일 금지 + 중앙 재정렬만
           - Group (텍스트 미포함) / 기타: 비례 스케일
     - if obj.meta?.regionRef in ['front-cover', 'front-wing']:
         → 이동은 "객체 중심점" 기준으로 수행:
           c = obj.getCenterPoint()
           c' = (c.x + Δx, c.y)
           obj.setPositionByOrigin(c', 'center', 'center')
         → 그룹 내부 객체는 그룹 자체만 이동 (하위 건드리지 않음)
     - if obj.meta?.regionRef in ['back-cover', 'back-wing']:
         → 변동 없음

  6. 기존 가이드/라벨 제거 → 새 레이아웃으로 재렌더링
  7. currentLayout = newLayout

  8. canvas.renderOnAddRemove = true  // 렌더링 잠금 해제
  9. setZoomAuto() + requestRenderAll()  // 마지막에 zoom
  10. 토스트 알림 + emit('spineWidthChange')
  ※ 캔버스 밖으로 나간 자유 객체가 있으면 추가 경고 토스트
```

**좌표계 기준 규칙**:
- resizeSpine 트랜잭션 동안은 줌/패닝/스냅 계산을 oldLayout 기준으로 하지 않고, **newLayout 확정 이후 기준으로만** 수행한다.
- 트랜잭션 중간 상태에서 좌표 계산이 일어나면 안 됨 (renderOnAddRemove=false로 보장)

**사용자 입력 잠금** (`isLayoutTransaction` 플래그):
- **잠금 트리거**: resizeSpine() 진입 시 `isLayoutTransaction = true`
- **잠금 해제**: resizeSpine() finally에서 **반드시** 해제
- **잠금 중 금지**: `object:moving`, `object:scaling`, `selection:*` → early-return
- **잠금 중 허용**: 캔버스 pan/zoom (선택/변형만 금지)
- **키보드**: delete 허용, undo/redo 허용하되 실행 시 pending spine API cancel 후 immediateRecalcSpine 1회
- 잠금은 **UI 레벨**(툴 비활성) + **플러그인 레벨**(이벤트 핸들러 early-return)로 이중 적용

**Debounce + Cancel** (R4 반영):
- 내지 추가/삭제 → spine API 호출: `debounce(300ms)` + `AbortController`로 in-flight cancel
- 연타 시 마지막 요청만 실행, 이전 요청은 자동 취소

**History Replay 상태 플래그**:
- `restoring: boolean` 플래그를 useAppStore에 추가
- history replay 시작 시점에 `restoring=true`, replay 종료 직후 `restoring=false`
- `restoring=true` 동안에는 spine API 호출을 누적하지 않고, **마지막 상태 1회만 즉시 실행**
- in-flight cancel은 유지 (복원 전 pending 요청은 취소)

### 4.3 상태 관리 변경

**useSettingsStore** (`apps/editor/src/stores/useSettingsStore.ts`):
```typescript
// 추가 상태
spreadConfig: SpreadConfig | null   // null이면 비-스프레드 모드

// 추가 액션
setSpreadConfig(config: SpreadConfig | null): void
updateSpreadSpineWidth(newWidthMm: number): void
```

**useAppStore** (`apps/editor/src/stores/useAppStore.ts`):
```typescript
// 추가 상태
isSpreadMode: boolean
spreadCanvasIndex: number  // 항상 0
spineResizeAbortController: AbortController | null  // in-flight cancel용
restoring: boolean  // history replay 중 여부 (debounce 비활성 제어)
isLayoutTransaction: boolean  // resizeSpine 중 여부 (입력 잠금 제어)

// 추가 액션
addInnerPage(): Promise<void>     // 내지 추가 → debouncedRecalcSpine()
deleteInnerPage(canvasId): void   // 내지 삭제 → debouncedRecalcSpine()
setSpreadMode(enabled: boolean): void
debouncedRecalcSpine(): void      // debounce(300ms) + abort
```

**스프레드 모드 캔버스 구조**:
- `allCanvas[0]`: 스프레드 캔버스 (표지 전체)
- `allCanvas[1~N]`: 내지 캔버스 (기존과 동일)

**히스토리 연동 정책**:
- `addInnerPage()` / `deleteInnerPage()`: History에 push (문서 구조 변경 = undo 가능)
- `SpreadPlugin.resizeSpine()`: History **비대상** (레이아웃 보정은 부수효과)
- **undo/redo + debounce 충돌 규칙**:
  - 히스토리 복원 중에는 debounce **비활성** → 마지막 상태에서 **즉시 1회만** spine 계산
  - in-flight cancel은 유지 (복원 전 pending 요청은 취소)
  - 복원 흐름: `undo() → cancelPending() → immediateRecalcSpine()`

**spineCalculator.ts** (`apps/editor/src/utils/spineCalculator.ts`):
- 스프레드 모드: `SpreadPlugin.resizeSpine()` 호출로 위임
- 비-스프레드 모드: 기존 로직 유지 (하위호환)

### 4.4 관리자 페이지 변경

#### TemplateSet 엔티티 변경
```typescript
@Column({ name: 'editor_mode', type: 'varchar', length: 20, default: 'single' })
editorMode: EditorMode  // 'single' | 'book'
```

#### Template 엔티티 변경
```typescript
@Column({ name: 'spread_config', type: 'json', nullable: true })
spreadConfig: SpreadConfig | null  // spread 타입일 때만 사용
```

#### SpreadConfig 입력 최소화 (R5 반영)

관리자가 입력하는 값은 **최소한**으로 유지:
```
필수: coverWidthMm, coverHeightMm, wingEnabled, wingWidthMm
선택: initialSpineWidthMm (미입력 시 product_sizes에서 자동 계산)
```
나머지(cutSize, safeSize, dpi, regions 등)는 에디터가 `product_sizes` + `SpreadLayoutEngine.computeLayout()`으로 **자동 산출**.

#### API 서버 검증 강화 (3.1 반영)

**CreateTemplate 시점**:
- type='spread'일 때 spreadConfig 필수 필드 검증
- coverWidthMm/coverHeightMm 범위 검증 (product_sizes와 일치 여부)

**CreateTemplateSet / UpdateTemplateSet 시점**:
```
editorMode='book':
  - SPREAD 타입 템플릿 정확히 1개 필수 → 없으면 400 에러
  - WING/COVER/SPINE 타입 불허 → 있으면 400 에러
  - PAGE 타입 1개 이상 필수

editorMode='single':
  - SPREAD 타입 불허 → 있으면 400 에러
  - 기존 검증 그대로
```

**상품 스펙 일치 검증** (실무에서 가장 깨지기 쉬운 부분):
```
TemplateSet이 상품에 연결될 때:
  - spreadConfig.spec.coverWidthMm == product.width → 불일치 시 400
  - spreadConfig.spec.coverHeightMm == product.height → 불일치 시 400
  - spreadConfig.spec.wingEnabled == product.wingEnabled → 불일치 시 400
```
Admin UI에서만 막으면 운영에서 우회 데이터가 들어오므로, **서버에서 강제**.

**EditSession 생성 시점 검증**:
- 세션 생성 API에서도 SpreadSpec vs 상품 스펙 재검증
- 상품 스펙이 (운영 중) 변경된 경우: 불일치하면 세션 생성 실패 (400 에러)
- 기존 세션은 유지 (이미 저장된 스냅샷 기준으로 동작)

#### 관리자 TemplateEditor 변경 (`apps/admin/src/pages/Templates/TemplateEditor.tsx`)
- 템플릿 생성 시 type='spread' 선택 가능
- spread 타입 선택 시 최소 설정 모달:
  - 표지 크기 (W x H mm)
  - 날개 포함 여부 + 날개 크기
  - (선택) 초기 책등 크기
- iframe URL에 `mode=spread&spec=...` 전달 (최소 스펙만)
- 에디터가 SpreadLayoutEngine으로 나머지 자동 산출 후 스프레드 모드로 열림

```
관리자 스프레드 템플릿 생성 플로우:
1. [+ 새 템플릿] → 타입 'spread' 선택
2. 최소 설정 모달: 표지크기, 날개여부 (나머지 자동)
3. iframe 에디터가 스프레드 모드로 오픈
4. 관리자가 스프레드 뷰에서 디자인 편집
5. 저장 → Template { type: 'spread', canvasData, spreadConfig(자동산출) } 저장
```

#### 관리자 TemplateSetForm 변경 (`apps/admin/src/pages/TemplateSets/TemplateSetForm.tsx`)
- `editorMode` 선택 필드 추가 (Radio: '단일모드' / '책모드')
- 책모드 선택 시:
  - 스프레드 템플릿(type=spread) 1개 필수
  - 내지 템플릿(type=page) N개
  - 기존 wing/cover/spine 개별 템플릿은 추가 불가 (경고 표시)
- 단일모드 선택 시: 기존과 동일

### 4.5 초기화 흐름 변경

**useEditorContents.ts** (`apps/editor/src/hooks/useEditorContents.ts`):

```
loadTemplateSetEditor():
  1. 상품/템플릿셋 조회
  2. 상품 설정의 editorMode 확인 ('single' | 'book')

  if (editorMode === 'book'):
    3. 스프레드 템플릿에서 SpreadSpec 추출:
       - template.spreadConfig.spec (저장된 최소 스펙)
       + product_sizes.cutSize, safeSize (상품 스펙에서 보완)
    4. SpreadLayoutEngine.computeLayout(spec) → SpreadLayout 생성
    5. 스프레드 캔버스 1개 생성 (layout.totalWidthPx × layout.totalHeightPx)
       → createCanvas에서 SpreadPlugin 자동 등록
    6. 스프레드 템플릿의 canvasData를 로드
       → 객체의 meta.regionRef/anchor 초기화 규칙:
         - 이미 존재하면 그대로 사용
         - 누락 시(관리자 초기 생성/과거 데이터):
           - regionRef = null
           - primaryRegionHint = resolveRegionAtX(center.x) (가능하면)
           - anchor = { kind: 'canvas', x: center.x, y: center.y }
         - 출력/Worker 스냅샷과 무관한 UI 메타이므로 누락은 소프트 경고 허용
    7. 내지 캔버스들 생성 (기존 방식)
    8. 책등 초기 계산 + EditSession.metadata.spine 스냅샷 저장
  else:
    기존 로직 유지
```

**createCanvas.ts** (`apps/editor/src/utils/createCanvas.ts`):
- `initPlugins()`에서 `spreadSpec` 존재 시 `SpreadPlugin` 조건부 등록

### 4.5-2 UI 컴포넌트

**새 파일**: `apps/editor/src/components/PagePanel/SpreadPagePanel.tsx`
```
┌─────────────────────────────────────────────────────────────┐
│ [스프레드 썸네일 (200x60px)]  |  [내지1][내지2]...[+]       │
│    "표지 스프레드"             |   정방형 썸네일 나열          │
└─────────────────────────────────────────────────────────────┘
높이: 100px 고정, 항상 표시
```

**EditorView.tsx 레이아웃 변경**: 스프레드 모드 시 flex-col 구조 + 하단 SpreadPagePanel

**새 파일**: `apps/editor/src/components/Mockup3D/BookMockup3D.tsx`
- CSS 3D transform 기반 책 목업 모달
- crop 좌표는 **SpreadLayoutEngine 산출물**(regions)에서 계산 (raw SpreadConfig 직접 참조 금지)
- 회전 슬라이더로 각도 조절

**새 파일**: `apps/editor/src/utils/cropRegions.ts`
- SpreadLayout.regions에서 region별 영역 crop 좌표 계산 유틸리티
- 입력: SpreadLayout + screenshot dimensions → 출력: region별 crop rect

**EditorHeader.tsx**: '3D 미리보기' 버튼 추가

### 4.6 타입 정의 추가

**packages/types/src/index.ts**:
```typescript
// 에디터 모드 enum 추가
export enum EditorMode {
  SINGLE = 'single',
  BOOK = 'book',
}

// TemplateType enum에 추가
SPREAD = 'spread'

// 스프레드 영역 위치
export type SpreadRegionPosition =
  'back-wing' | 'back-cover' | 'spine' | 'front-cover' | 'front-wing'

// 객체 앵커 메타 (R1 반영)
export type ObjectAnchor =
  | { kind: 'region'; xNorm: number; yNorm: number }
  | { kind: 'canvas'; x: number; y: number }

export interface SpreadObjectMeta {
  regionRef: SpreadRegionPosition | null
  primaryRegionHint: SpreadRegionPosition | null  // UX용 (자유 객체의 주 영역 힌트)
  anchor: ObjectAnchor
}

// 시스템 객체 식별 메타 (2.2 반영)
export type SystemObjectType =
  'workspace' | 'cutBorder' | 'safeBorder' | 'spreadGuide' | 'dimensionLabel'

// 세션 스냅샷 (1.10 반영)
export interface SpineSnapshot {
  pageCount: number
  paperType: string
  bindingType: string
  spineWidthMm: number
  formulaVersion: string
}

export interface SpreadSpec { ... }    // 4.1.1 참고
export interface SpreadRegion { ... }  // 4.1.1 참고
export interface SpreadLayout { ... }  // 4.1.1 참고
export interface SpreadConfig { ... }  // 4.1.2 참고
export interface SpreadResizeEvent {
  oldSpineWidth: number  // mm
  newSpineWidth: number  // mm
  oldLayout: SpreadLayout
  newLayout: SpreadLayout
}
```

### 4.7 PDF 출력 변경

#### Worker Synthesis 분기 (`apps/worker/src/processors/synthesis.processor.ts`)

기존 `handleMergeSynthesis()`, `handleSplitSynthesis()`에 **`handleSpreadSynthesis()`** 추가:

```
handleSynthesis(job):
  switch (job.data.mode):
    'merge'  → handleMergeSynthesis()   // 기존
    'split'  → handleSplitSynthesis()   // 기존
    'spread' → handleSpreadSynthesis()  // 신규
```

#### handleSpreadSynthesis 흐름

```
handleSpreadSynthesis(job):
  1. 스냅샷 검증 (하드 실패 체크):
     - metadata.spine.spineWidthMm 필수
     - metadata.spread.totalWidthMm, spec 필수
     - 누락 시 → Job FAILED + 에러 로그 (재계산 금지)

  2. 스프레드 PDF 로드 (spreadPdfFileId):
     - 이중 검증: generatedBy='editor', editSessionId 일치
     - 페이지 수 검증: 정확히 1페이지여야 함
     - 사이즈 검증: MediaBox가 metadata.spread.totalWidthMm/totalHeightMm(+dpi 변환)와 일치
     - **오차 허용**: <= 0.2mm 또는 <= 1px@dpi 중 큰 값 (부동소수/라운딩 대응)
     - 허용치 이내여도 재계산 금지, 허용치 초과 시 하드 실패

  3. 내지 PDF 로드 (contentPdfFileIds[]):
     - 순서대로 로드 + 병합 → content.pdf
     - 총 페이지 수 = sum(각 PDF 페이지 수)

  4. 출력 파일 생성:
     - cover.pdf: 스프레드 PDF 그대로 복사 (1페이지)
     - content.pdf: 내지 병합 결과

  5. (선택) merged.pdf 생성:
     - alsoGenerateMerged=true 시: cover(1p) + content(Np) 합본

  6. 스토리지 업로드 → 웹훅 콜백

  ※ 처리 중 임시 디렉토리: temp/temp_${jobId}/ (jobId scoped, 기존 패턴)
```

#### Worker Job DTO 변경 (`apps/api/src/worker-jobs/`)

**CreateSpreadSynthesisJobDto** (신규):
```typescript
{
  sessionId: string
  spreadPdfFileId: string          // 스프레드 PDF (1페이지)
  contentPdfFileIds: string[]      // 내지 PDF들 (순서 보장)
  requestId: string                // 멱등성 키
  outputFormat: 'separate'         // 항상 separate (스프레드 모드는 분리 고정)
  alsoGenerateMerged?: boolean     // merged.pdf도 생성할지
  callbackUrl: string              // 웹훅 수신 URL
}
```

#### 세션 스냅샷과 Worker의 관계

- **spineWidthMm**: EditSession.metadata.spine에 저장된 값 우선 사용 (재계산 금지)
- **spread 총폭/스펙**: EditSession.metadata.spread에서 조회
- 외부 요인(종이 두께/제본 마진 정책) 변경과 무관하게 세션 저장 시점 값 재현

**스냅샷 실패/경고 기준**:
- **실패(하드)**: spineWidthMm 누락, spread totalWidthMm 누락, spec 누락, formulaVersion 불명 → Job 실패 + 에러 로그
- **경고(소프트)**: primaryRegionHint 누락, labels/guides 관련 누락, UI-only 메타 누락 → 정상 진행 + 경고 로그
- 자동 fallback(재계산) 금지 원칙 유지

### 4.8 기존 코드 재사용

| 기존 코드 | 재사용 |
|-----------|--------|
| `WorkspacePlugin.setOptions()` | 전체 크기 변경 시 그대로 사용 |
| `WorkspacePlugin.createOrUpdateCutBorder()` | 외곽 재단선 자동 처리 |
| `WorkspacePlugin.setZoomAuto()` | 줌 자동 맞춤 |
| `ScreenshotPlugin` | 스프레드 스크린샷 |
| `spineApi.calculate()` | API 호출 동일 |
| `mmToPxDisplay()` | 단위 변환 |
| `PageItem.tsx` | 내지 썸네일에 재사용 |

---

## 5. 수정 파일 목록

### 새 파일 (8개)
| 파일 | 설명 |
|------|------|
| `packages/canvas-core/src/spread/SpreadLayoutEngine.ts` | Pure 레이아웃 엔진 (테스트 핵심) |
| `packages/canvas-core/src/spread/SpineResizeStrategy.ts` | 타입별 리사이즈 전략 (text/image/group) |
| `packages/canvas-core/src/plugins/SpreadPlugin.ts` | Fabric 연동 스프레드 플러그인 |
| `apps/editor/src/components/PagePanel/SpreadPagePanel.tsx` | 하단 페이지 패널 |
| `apps/editor/src/components/Mockup3D/BookMockup3D.tsx` | 3D 목업 모달 |
| `apps/editor/src/utils/cropRegions.ts` | SpreadLayout 기반 영역 crop 유틸리티 |
| `apps/editor/src/utils/buildSpreadSpec.ts` | Template → SpreadSpec 변환 유틸리티 |
| `apps/editor/src/components/PagePanel/SpreadThumbnailItem.tsx` | 스프레드 썸네일 컴포넌트 |

### 수정 파일 (21개)
| 파일 | 변경 내용 |
|------|----------|
| `packages/types/src/index.ts` | EditorMode, ObjectAnchor, SpreadObjectMeta, SystemObjectType, SpineSnapshot 등 타입 추가 |
| `packages/canvas-core/src/index.ts` | SpreadPlugin, SpreadLayoutEngine export 추가 |
| `packages/canvas-core/src/models/CanvasSettings.ts` | spreadMode, spreadSpec 필드 |
| `apps/editor/src/stores/useSettingsStore.ts` | spreadConfig, spreadLayout 상태/액션 |
| `apps/editor/src/stores/useAppStore.ts` | isSpreadMode, addInnerPage, deleteInnerPage, debouncedRecalcSpine |
| `apps/editor/src/utils/createCanvas.ts` | SpreadPlugin 조건부 등록 |
| `apps/editor/src/hooks/useEditorContents.ts` | loadTemplateSetEditor 스프레드 분기 |
| `apps/editor/src/utils/spineCalculator.ts` | 스프레드 모드 분기 (debounce + abort) |
| `apps/editor/src/views/EditorView.tsx` | 하단 패널 레이아웃 |
| `apps/editor/src/components/editor/EditorHeader.tsx` | 3D 미리보기 버튼 |
| `apps/worker/src/services/pdf-synthesizer.service.ts` | spread 모드 합성 + spine 스냅샷 우선 사용 |
| `apps/api/src/templates/entities/template.entity.ts` | spreadConfig JSON 필드 추가 |
| `apps/api/src/templates/entities/template-set.entity.ts` | editorMode 필드 추가 |
| `apps/api/src/templates/dto/` | CreateTemplateDto, CreateTemplateSetDto에 새 필드 + 검증 |
| `apps/api/src/templates/templates.service.ts` | editorMode별 템플릿 구성 서버 검증 로직 |
| `apps/api/src/worker-jobs/worker-jobs.service.ts` | createSpreadSynthesisJob() 추가 |
| `apps/api/src/worker-jobs/dto/` | CreateSpreadSynthesisJobDto 추가 |
| `apps/api/src/edit-sessions/edit-sessions.service.ts` | 완료 시 spread 모드 분기 + 스냅샷 검증 |
| `apps/editor/src/hooks/useWorkSave.ts` | 스프레드 모드 PDF 생성/업로드 분기 |
| `apps/admin/src/pages/Templates/TemplateEditor.tsx` | spread 타입 생성 모달 (최소 입력) + iframe 스프레드 모드 |
| `apps/admin/src/pages/TemplateSets/TemplateSetForm.tsx` | editorMode 선택 + 책모드 구성 제한 |

---

## 6. 검증 방법

### 단위 테스트 (우선순위 순)

**1순위: SpreadLayoutEngine (Pure - 테스트 90% 커버)**
- `computeLayout()`: 다양한 SpreadSpec → regions/guides/labels 정확성
- `computeResizedLayout()`: spine 폭 변경 → 전체 레이아웃 delta 정확성
- `resolveRegionAtX()`: x-range 기반 영역 판정 정확성 (경계값 포함)
- `computeObjectReposition()`: 객체 앵커별 재배치 좌표 정확성

**2순위: SpineResizeStrategy (타입별 전략)**
- TextResizeStrategy: 스케일 금지 + 중앙 재정렬만 확인
- ImageResizeStrategy: 비례 스케일 + strokeUniform 보정 확인
- GroupResizeStrategy (텍스트 포함): 스케일 금지 + 중앙 재정렬 확인
- GroupResizeStrategy (텍스트 미포함): 비례 스케일 확인

**2.5순위: RegionRef 판정**
- 히스테리시스: 승격(90%)/강등(70%) 임계치 동작 확인
- 회전 객체가 경계 근처에 있을 때 판정 흔들림 없음 확인
- stroke가 큰 도형: getBoundingRect(true) 기준 통일 확인
- clip/crop 이미지의 판정/리사이즈 정확성

**3순위: 기타 Pure 유틸**
- `buildSpreadSpec`: Template → SpreadSpec 변환
- `cropRegions`: SpreadLayout → region별 crop rect
- API 검증: editorMode별 템플릿 구성 제약 검증

**4순위: SpreadPlugin (얇은 통합)**
- LayoutEngine 결과가 Fabric 오브젝트에 올바르게 반영되는지만

### 통합 테스트
1. 에디터에 책자 상품 로드 → 스프레드 캔버스 정상 생성 확인
2. 내지 추가 → 책등 폭 증가 → 앞표지 객체 우측 이동 확인
3. 내지 삭제 → 책등 폭 감소 → 앞표지 객체 좌측 이동 확인
4. **걸치기 객체**: 이미지가 back-cover→spine 걸친 상태에서 spineWidth 변경 → 절대좌표 유지 확인
5. 스프레드 캔버스에서 영역 경계 점선/치수 라벨 표시 확인
6. 객체를 영역 경계에 가져갔을 때 스냅 동작 확인
7. 하단 페이지 패널에서 스프레드/내지 썸네일 표시 + 선택 동작 확인
8. 3D 미리보기 모달 열기 → 책 형태 표시 확인
9. 저장 → 로드 → 스프레드 상태 복원 확인 (regionRef/anchor 메타 포함)
10. PDF 출력 → 스프레드가 1페이지 cover.pdf + 내지가 N페이지 content.pdf로 분리 확인
10-1. spread 모드 Worker Job: spreadPdfFileId 1페이지 검증 → 2페이지면 실패 확인
10-2. content PDF 병합: 내지 순서가 sortOrder와 일치하는지 확인
10-3. alsoGenerateMerged=true → merged.pdf(cover+content 합본) 정상 생성 확인
10-4. 스냅샷(spine/spread) 누락 → Job 하드 실패 확인
11. **연타/취소 시나리오**: + 버튼 연타 → debounce + cancel 동작 확인
12. **undo/redo**: 내지 삭제 → undo → 내지 복원 + spine 즉시 재계산 (debounce 비활성) 확인
13. **undo/redo 연속**: undo→redo→undo 연속 실행 시 debounce/cancel 충돌 없음 확인
14. **서버 검증**: editorMode=book + COVER 타입 템플릿 → 400 에러 확인
15. **서버 검증**: 상품 스펙과 spreadConfig 불일치 → 400 에러 확인
16. **Worker 스냅샷 누락**: metadata.spine/spread 누락 시 재계산 없이 Job 실패 확인

### E2E 테스트 (Playwright)
- 에디터 접속 → 페이지 추가 → 책등 변경 확인 → PDF 다운로드 전체 플로우
- 관리자 → 스프레드 템플릿 생성 → 템플릿셋 구성 → 에디터에서 확인 전체 플로우
